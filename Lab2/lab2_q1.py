# -*- coding: utf-8 -*-
"""Lab2_Q1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GNxZvRS1JhmR5qQUc4nMeagFipB-BGiQ

Concordia COMP 6721 Summer 2023 <br>
Lab Assignment 2 State Space Search (sample implementation) <br>
Question 1
"""

'''
State = position(farmer, fox, goose, beans)
Let's assume 
0: Original bank
1: Far bank 

Initial state = (0,0,0,0) Eqv to 0000 = 0 
Goal state  = (1,1,1,1) Eqv to 1111 = 15
Illegal states = 
8 = (1,0,0,0)
7 = (0,1,1,1)

9 = (1,0,0,1)
6 = (0,1,1,0)

3 = (0,0,1,1)
12 = (1,1,0,0)

Actions (|: Logical OR,  &: Logical AND)
moveFar(farmer, empty) (newState = oldState | 1000)
moveFar(farmer, fox)   (newState = oldState | 1100)
moveFar(farmer, goose) (newState = oldState | 1010)
moveFar(farmer, beans) (newState = oldState | 1001)

moveBack(farmer, empty) (newState = oldState & 0111)
moveBack(farmer, fox)   (newState = oldState & 0011)
moveBack(farmer, goose) (newState = oldState & 0101)
moveBack(farmer, beans) (newState = oldState & 0110)

If farmer is on the original side (0<= state <=7) moveFar actions are allowed.
If farmer ison the far side (8<= state <=15) moveBack actions are allowed.

'''

"""Auxilary functions to present the actions and states in a user-friendly manner"""

def get_state_description (s):
  '''
  Inputs:
    s: Integer state variale in [0, 15] 
  Outputs:
        A string describing the state
  '''
  return ['f' if int(i) else 'o' for i in '{0:04b}'.format(x_states)]

def get_action_description (state, child):
  '''
  Inputs:
    s:     Integer state variale in [0, 15] indicating original state
    child: Integer state variale in [0, 15] indicating child state
  Outputs:
        A string describing the action of going from state to child
  '''
  DESCRIPTION = ['farmer', 'fox', 'goose', 'beans']
  bit_changes = state ^ child  # XOR
  entities_movement = ([DESCRIPTION[pos] if int(val) else '' for pos,val in enumerate('{0:04b}'.format(bit_changes))])
  moved_entities = [item for item in entities_movement if item]
  if state > child:
    return 'moveBack(' + ','.join(moved_entities) +')'
  else:
    return 'moveFar(' + ','.join(moved_entities) +')'

def get_state_children (s):
  '''
  Inputs:
    s: Integer state variale in [0, 15] 
  Outputs:
        List of children (next states) reachable from state s

  returns the list of states which can be reached from this state with a legal action
  '''
  if 0<=s and s<=7:
    return [s | 8, s | 9, s | 10, s | 12 ]
  elif 8<=s and s<=15:
    return [s & 7, s & 6, s & 5, s & 3 ]
  else:
      print('State is supposed to be between 0 and 15')
      return []

"""BFS implementation"""

start_state = 0
goal_state = 15
closed_states = [] # Visited nodes
open_states  = [start_state] # Queue: To be visited
actions=['Start'] # Optional: Bookkeeping of actions 
success = 0 
illegal_states = [8,7,9,6,3,12] 

while open_states:
    x_states = open_states.pop(0)
    action = actions.pop(0) 
    print (action,  '->' , '{0:04b}'.format(x_states), get_state_description(x_states))
    if x_states == goal_state:
      success =1 
      break
    else:
      closed_states.append(x_states)
      for child in get_state_children(x_states):
        if child not in illegal_states and child not in closed_states and child not in open_states:
          open_states.append(child)
          actions.append(get_action_description(x_states, child))

if success:
  print('SUCCESS')
else:
  print('FAILUER')

"""DFS Implementation"""

start_state = 0
goal_state = 15
closed_states = [] # Visited nodes
open_states  = [start_state] # Queue: To be visited
actions=['Start'] # Optional: Bookkeeping of actions 
success = 0 
illegal_states = [8,7,9,6,3,12] 

while open_states:
    x_states = open_states.pop(0)
    action = actions.pop(0) 
    print (action,  '->' , '{0:04b}'.format(x_states), get_state_description(x_states))
    if x_states == goal_state:
      success =1 
      break
    else:
      closed_states.append(x_states)
      for child in get_state_children(x_states):
        if child not in illegal_states and child not in closed_states and child not in open_states:
          open_states.insert(0, child)
          actions.append(get_action_description(x_states, child))

if success:
  print('SUCCESS')
else:
  print('FAILUER')