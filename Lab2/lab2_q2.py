# -*- coding: utf-8 -*-
"""Lab2_Q2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iNrmm2Qq5lcrnCOyxt5R8xW9MejnG4NB

Concordia COMP 6721 Summer 2023 <br>
Lab Assignment 2 State Space Search (sample implementation) <br> 
Question 2
"""

# Cost of actions given in the question
ACTION_COST = {
    ('A','C'):1,
    ('A','D'):6,
    ('B','G2'):9,
    ('B','E'):1,
    ('C','S'):2,
    ('C','D'):4,
    ('D','G1'):6,
    ('D','B'):3,
    ('E','G2'):5,
    ('G1','C'):2,
    ('G2','B'):8,
    ('S','A'):3,
    ('S','B'):7
}

# Heuristic evaluation of the states, given in the question
HEURISTIC_EVAL = {'A':5, 'B':8, 'C':3, 'D':2, 'E':4, 'G1':0, 'G2':0, 'S':10}

def get_state_children (s):
  '''
  Inputs:
    s:  state variable where s in ['A', 'B', 'C', 'D', 'E', 'G1', 'G2', 'S'] 
  Outputs:
        List of children (next states) reachable from state s

  returns the list of states which can be reached from this state with a legal action
  Sort  alphabetically
  '''
  children = sorted([item[1] for item in ACTION_COST.keys() if item[0]==s])
  return children

"""a) BFS Implementation"""

start_state ='S'
goal_state = ['G1', 'G2']
closed_states = [] # Visited nodes
open_states  = [start_state] # Queue: To be visited
success = 0 

while open_states:
    x_states = open_states.pop(0)
    print ('Just visited state: ', x_states )
    if x_states in goal_state:
      success =1 
      break
    else:
      closed_states.append(x_states)
      for child in get_state_children(x_states):
        if child not in closed_states and child not in open_states:
          open_states.append(child)

    print('closed_states: ', closed_states)
    print('open_states: ', open_states, '\n')

if success:
  print('SUCCESS')
else:
  print('FAILUER')

"""b) Depth-first Search"""

start_state ='S'
goal_state = ['G1', 'G2']
closed_states = [] # Visited nodes
open_states  = [start_state] # Queue: To be visited
success = 0 

while open_states:
    x_states = open_states.pop(0)
    print ('Just visited state: ', x_states )
    if x_states in goal_state:
      success =1 
      break
    else:
      closed_states.append(x_states)
      children_inv_sorted = sorted(get_state_children(x_states), reverse=True) # Question asks for alphabetical insertion
      for child in children_inv_sorted:
        if child not in closed_states and child not in open_states:
          open_states.insert(0, child)

    print('closed_states: ', closed_states)
    print('open_states: ', open_states, '\n')

if success:
  print('SUCCESS')
else:
  print('FAILUER')

"""(c) Iterative deepening depth-first search"""

start_state ='S'
goal_state = ['G1', 'G2']
closed_states = [] # Visited nodes
open_states  = [start_state] # Queue: To be visited
success = 0 
MAX_DEPATH = 4

allowed_depth =1
while allowed_depth < MAX_DEPATH:
  closed_states = [] # Visited nodes
  open_states  = [start_state] # Queue: To be visited
  depth_dict = {'S':1}
  print('Allowed depth: ', allowed_depth)
  print('--------------------------------------')
  while open_states:
      x_states = open_states.pop(0)
      depth_of_current_state = depth_dict[x_states]
      print ('Just visited state: ', x_states, "({})".format(depth_of_current_state) )
      if x_states in goal_state:
        success =1 
        break
      else:
        closed_states.append(x_states)
        if depth_of_current_state < allowed_depth:
          children_inv_sorted = sorted(get_state_children(x_states), reverse=True) # Question asks for alphabetical insertion
          for child in children_inv_sorted:
            if child not in closed_states and child not in open_states:
              open_states.insert(0, child)
              depth_dict[child]=depth_dict[x_states]+1

      print('closed_states: ', closed_states)
      print('open_states: ', open_states, '\n')

  if success:
    print('SUCCESS')
    break
  else:
    allowed_depth+=1

"""(d) Uniform cost search (different costs)"""

start_state ='S'
goal_state = ['G1', 'G2']
closed_states = [] # Visited nodes
open_states  = [[start_state, 0]] # Queue: We implement it as a list
success = 0 

while open_states:
    x_state_tuple = open_states.pop(0)
    x_states = x_state_tuple[0] # State
    x_cost  = x_state_tuple[1] # State cost 

    print ('Just visited state: ', x_states, 'Cost: ({})'.format(x_cost) )
    if x_states in goal_state:
      success =1 
      break
    else:
      closed_states.append(x_states)
      open_state_only = [item[0] for item in open_states]
      for child in get_state_children(x_states):
        new_child_cost = x_cost+ACTION_COST[(x_states, child)]
        if child not in closed_states and child not in open_state_only:
          open_states.append([child, new_child_cost ])
        elif child in open_state_only: 
          '''Already in the list: Find and update it'''
          for state_item in open_states:
            if state_item[0]==child:
              state_item[1] = min(state_item[1], new_child_cost)
              break
        
      open_states.sort(key=lambda x: x[1])  # Sort step
 
    print('closed_states: ', closed_states)
    print('open_states: ', open_states, '\n')

if success:
  print('SUCCESS')
else:
  print('FAILUER')

"""(e) Hill climbing"""

start_state ='S'
goal_state = ['G1', 'G2']
success = 0 
current_state = start_state
current_evaluation = HEURISTIC_EVAL[current_state]

while True:
    print ('Just visited state: ', current_state, 'Heuristic evaluated cost: ({})'.format(current_evaluation) )
    if current_state in goal_state:
      success =1 
      break
    else:
      is_better_neighbor_found=False
      for child in get_state_children(current_state):
        if HEURISTIC_EVAL[child] <= current_evaluation:
          current_state = child
          current_evaluation = HEURISTIC_EVAL[child]
          is_better_neighbor_found = True
          break
        else:
          print('Evaluated cost child {} ({}) > Evaluated cost parent {} ({})'.format(child, HEURISTIC_EVAL[child],current_state,current_evaluation ))
      if not is_better_neighbor_found:
        print('Hill Climbing is stuck at the current state and terminates.')
        break
        
if success:
  print('SUCCESS')
else:
  print('FAILUER')

"""(f) Best-first search"""

start_state ='S'
goal_state = ['G1', 'G2']
closed_states = [] # Visited nodes
open_states  = [[start_state, HEURISTIC_EVAL[start_state]]] # Queue: We implement it as a list of [state, evalution of state]
success = 0 

while open_states:
    x_state_tuple = open_states.pop(0)
    x_states = x_state_tuple[0] # State
    x_cost  = x_state_tuple[1] # State cost 

    print ('Just visited state: ', x_states, 'Cost: ({})'.format(x_cost) )
    if x_states in goal_state:
      success =1 
      break
    else:
      only_open_states = [item[0] for item in open_states] # Only the states' names without the evaluation
      closed_states.append(x_states)
      for child in get_state_children(x_states):
        if child not in closed_states and child not in only_open_states:
          open_states.append([child, HEURISTIC_EVAL[child]])
                
      '''Sort step to make the list a priority queue'''
      open_states.sort(key=lambda x: x[1]) 
 
    print('closed_states: ', closed_states)
    print('open_states: ', open_states, '\n')

if success:
  print('SUCCESS')
else:
  print('FAILUER')

"""(g) Algorithm A  """

start_state ='S'
goal_state = ['G1', 'G2']
closed_states = [] # Visited nodes
open_states  = [[start_state, HEURISTIC_EVAL[start_state], 0]] # Queue: We implement it as a list of [state, evalution of state, path_cost]
success = 0 

while open_states:
    x_state_tuple = open_states.pop(0)
    x_states   = x_state_tuple[0] # State
    x_cost     = x_state_tuple[1] # State evaluated cost to goal 
    path_cost  = x_state_tuple[2] # Path cost from root to this state 

    print ('Just visited state: ', x_states, 'Evaluted cost to goal: ({})'.format(x_cost), 'Path cost from root: ({})'.format(path_cost) )
    if x_states in goal_state:
      success =1 
      break
    else:
      only_open_states = [item[0] for item in open_states] # Only the states' names without the evaluation
      closed_states.append(x_states)
      for child in get_state_children(x_states):
        if child not in closed_states and child not in only_open_states:
          open_states.append([child, HEURISTIC_EVAL[child], path_cost + ACTION_COST[(x_states, child)]])
        elif child in only_open_states: 
          '''Already in the list: Find and update it'''
          for state_item in open_states:
            if state_item[0]==child:
              state_item[2] = min(state_item[2], path_cost + ACTION_COST[(x_states, child)])
              break
                
      '''Sort step to make the list a priority queue (Sum of two costs)'''
      open_states.sort(key=lambda x: x[1]+x[2]) 
 
    print('closed_states: ', closed_states)
    print('open_states: ', open_states, '\n')

if success:
  print('SUCCESS')
else:
  print('FAILUER')